# SpringSecurity 적용 Oauth2

로그인 폼을 만드는데 Oauth2를 사용해서 토큰을 받는다.  백기선님의 인프런 Rest_API강좌를 참고하여 진행했다.



```xml
<dependency>
	<groupId>org.springframework.security.oauth.boot</groupId>
	<artifactId>spring-security-oauth2-autoconfigure</artifactId>
	<version>2.1.0.RELEASE</version>
</dependency>
```

먼저 의존성을 추가해준다.



스프링 시큐리티를 적용한 순간부터 모든 요청에 대한 검사를 진행하기 때문에 지금까지 구현한 Test는 모두 실패하게 된다.



UserDetailsService와 UserDetails라는 인터페이스가 있다.

스프링 시큐리티에서 사용자의 정보를 담는 인터페이스가 UserDetails이고 UserDetailsSerivce는 DB정보를 UserDetails라는 형태로 변환하는 인터페이스다.  쉽게 보면 UserDetails는 스프링 시큐리티에 접근하기 위한 객체이다.



UserDetailsService를 활용해 사용자의 정보를 UserDetails에 담아 리턴하는 클래스를 구현할 것이다.

##### AccountService

```java
@Service
public class AccountService implements UserDetailsService {

	@Autowired
	private AccountRepository accountRespository;

	@Autowired
	private ModelMapper modelMapper;

	@Override
	public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
		Account account = accountRespository.findByEmail(username)
				.orElseThrow(() -> new UsernameNotFoundException(username));
		
		return new User(account.getEmail(), account.getPassword(), authorities(account.getRoles()));
	}

	private Collection<? extends GrantedAuthority> authorities(Set<AccountRole> roles) {
		return roles.stream()
				.map(r -> new SimpleGrantedAuthority("ROLE_"+r.name()))
				.collect(Collectors.toSet());
	}
}
```

여기서 return하는 User는 UserDetails에 있는 구현체로 유저의 정보를 담을 수 있는 객체이다. 저것말고도 여러가지 정보를 담을 수 있다.

그리고 authorities 메소드는 role을 SimpleGrantedAuthority로 바꾸는 과정이다. 이부분은 잘 이해가 가지 않는다.



이제 Security의 설정을 한것이다.

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

}
```

이렇게 설정하는 순간 기존의 스프링시큐리티의 설정이 되지 않고 내가 하는 설정이 적용하게 된다.



PasswordEncoder가 필요하기 때문에 Bean에 추가해준다.

##### AppConfig

```java
@Configuration
public class AppConfig {
	
	@Bean
	public ModelMapper modelMapper() {
		return new ModelMapper();
	}
	
	@Bean
	public PasswordEncoder passwordEncoder() {
		return PasswordEncoderFactories.createDelegatingPasswordEncoder();
	}
}
```



이제 SecurityConfig를 해보겠다.

##### SecurityConfig

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
	
	@Autowired
	private AccountService accountService;
	
	@Autowired
	private PasswordEncoder passwordEncoder;
	
	@Bean
	public TokenStore tokenStore() {
		return new InMemoryTokenStore();
	}
	
	// AuthentiactionManger를 Bean으로 등록해서 노출시킨다.
	@Bean
	@Override
	protected AuthenticationManager authenticationManager() throws Exception {
		return super.authenticationManager();
	}
	
	// 노출된 AuthenticationManager를 어떻게 만들거냐
	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		auth.userDetailsService(accountService)
			.passwordEncoder(passwordEncoder);
		// userDetailsService와 PasswordEncoder는 내가만든것을 적용
	}

	// Web에서 필터의 적용 유무를 설정한다. 정적파일은 이곳에서 해주는게 좋다.
	@Override
	public void configure(WebSecurity web) throws Exception {
		web.ignoring().mvcMatchers("/docs/**");
		web.ignoring().requestMatchers(PathRequest.toStaticResources().atCommonLocations());
		web.ignoring().antMatchers("/assets/**");
	}
}
```

여기서 web과 http가 잇는데 web은 시큐리티에 들어가기 전에 걸러주는 것이다. http로 하면 일단 시큐리티에 들어가게 되고 시큐리티 필터 11개를 거치면서 서버가 더욱 많은 일을하게 된다. 그래서 정적파일의 경우는 web에서 걸려주는게 좋다.



```java
@Override
protected void configure(HttpSecurity http) throws Exception {
	http
		.anonymous()
			.and()
		.formLogin()
			.and()
		.authorizeRequests()
			.mvcMatchers(HttpMethod.GET, "/api/**").anonymous()
			.anyRequest().authenticated();
}
```

